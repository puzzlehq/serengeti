import puzzle_pieces_v008.leo;
import multiparty_pvp_utils_v008.leo;

// todo: wait we're going to use alice's credits to send to multisig? need to add credits.leo but not supported yet per https://github.com/AleoHQ/leo/pull/2881
// imports deployed to separate address: https://t.me/c/1766615939/3581

// todo: the primary issue is that we need to consume owner rules inside of puzzle transfers but we can't do that?
// todo: actually does this matter, there is only 1 owner rules record floating?
// todo: can we consume it inside of this program?
// todo: since if we do not consume it inside the transfer then someone could rug?
// todo: also when transferring to winner will need to transfer both records
// todo: can we do this with inline functions?

// The 'coinflip' program.
program wheres_alex_v008.aleo {

    // record PlayerOneClaim {}

    // record PlayerTwoClaim {}

    // record Claim {
    //     private owner: address,
    //     private amount: u64,
    // }

    // may want this to be more like NotifyGameStarted record
    // with the GameID on it
    // for FE to easily find
    //
    // record NotifyKeyRecord {
    //     private owner: address,
    //     private keys: field,
    //     private game_address: address,
    //     private challenge_amount: u64,
    //     private opponent: address,
    // }

    // todo: this will likely need to store each player answer
    // todo: may be best to store players in the game here on game record
    // todo: add block height to game record?
    record Game {
        owner: address,
        challenger_commit: field,
        opponent_answer: field,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
        game_multisig: address,
        game_state: field,
        // private game_state: field,
        // 1 -> proposed game
        // 2 -> accepted game
        // 3 -> finished game
    }

    // GAME STATE RECORDED ON NOTIFICATIONS
    // private game_state: field,
        // NORMAL FLOW
        // 1 -> challenger proposed game
        // 2 -> opponent matched wager
        // 3 -> accepted game
        // 4 -> challenger revealed answer
        // 5 -> finished game
        //
        // ALTERNATE EXIT PATHS
        // 6 -> timeout finished game

    // your turn:
        // true -> your turn or ms turn
        // false -> awaiting other party turn

    // sent to opponent on propose game for FE/client detection.
    // consumed in match wager
    record GameReqNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    // sent to challenger on propose game for FE/client detection.
    // consumed in reveal answer
    record WaitingAcceptanceNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    record StakeRenegedNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
        renege_address: address,
    }

    // sent to challenger on submit wager for FE/client detection.
    // consumed in reveal answer
    record ChallengerWagerNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    record OpponentWagerNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    // sent to opponent on accept game for FE/client detection.
    // consumed in finish_game/claim total pot
    record WaitingRevealNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    // sent to challenger on accept game for FE/client detection.
    // consumed in reveal answer
    record RevealAnswerNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
        opponent_answer: field,
    }

    // sent to opponent on reveal answer for FE/client detection.
    record GameFinishReqNotification {
        owner: address, //opponent
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
    }

    // sent to both opponent and challenger on finish game
    record GameFinishedNotification {
        owner: address,
        game_multisig: address,
        game_state: field,
        your_turn: bool,
        total_pot: u64,
        challenger_address: address,
        opponent_address: address,
        winner: address,
        loser: address,
    }

    // record NotifyGameOver {
    //     private owner: address,
    //     private winner: address,
    //     private total_pot: u64,
    //     private game_address: address,
    //     private opponent: address,
    // }

    // record NotifyAcceptGame {
    //     private owner: address,
    //     private total_pot: u64,
    //     private game_address: address,
    //     private opponent: address,
    // }

    // record RevealedAnswer {
    //     private owner: address,
    //     private answer: field,
    //     private nonce: field,
    // }



    // mapping puzz_supply: field => u128;
    // mapping games: address => u32;

    // New propose game
    transition propose_game (
        //puzzle_pieces.stake_transfer_in() data
        wager_record: puzzle_pieces_v008.leo/Piece.record,
        amount: u64,
        sender: address, // Challenger address proposing game
        challenger: address,
        opponent: address,
        game_multisig: address,
        message_1: field, //from output of useSignature
        message_2: field,
        message_3: field,
        message_4: field,
        message_5: field,
        sig: signature, //from output of useSignature
        //multiparty_pvp_utils data
        nonce: field,
        answer: field,
        seed: field, //game_multisig seed to send to user
        //wheres_alex data
    ) -> (
        puzzle_pieces_v008.leo/PieceClaim.record,
        puzzle_pieces_v008.leo/PieceStake.record,
        puzzle_pieces_v008.leo/ClaimSignature.record,
        puzzle_pieces_v008.leo/Piece.record,
        puzzle_pieces_v008.leo/AuditStakeIn.record,
        multiparty_pvp_utils_v008.leo/Answer.record,
        multiparty_pvp_utils_v008.leo/AuditMintAnswer.record,
        multiparty_pvp_utils_v008.leo/Key.record,
        multiparty_pvp_utils_v008.leo/AuditKey.record,
        Game,
        GameReqNotification,
        WaitingAcceptanceNotification,
    ) {


        // random edge case, maybe unnecessary
        assert_neq(game_multisig, opponent);

        // assert that player 1s answer is either "in weeds" or "behind building"
        assert(answer == 0field || answer == 1field);
        // hash the answer and nonce
        let challenger_commit: field = BHP256::commit_to_field(answer, nonce as scalar);

        // assert that the wager amount > 0 and wager inside credit == wager amt passed
        assert(amount > 0u64);
        // assert that the wager record has >= amount wagered
        assert(wager_record.amount >= amount);

        let (
            piece_claim,
            piece_stake,
            claim_signature,
            piece,
            audit_stake_in_record
        ): (
            PieceClaim,
            PieceStake,
            ClaimSignature,
            Piece,
            AuditStakeIn
        ) = puzzle_pieces_v008.leo/stake_transfer_in(
            wager_record,
            sender,
            challenger,
            opponent,
            game_multisig,
            amount,
            message_1,
            message_2,
            message_3,
            message_4,
            message_5,
            sig
        );

        let (
            key_record,
            audit_key_record
        ) : (
            Key,
            AuditKey
        ) = multiparty_pvp_utils_v008.leo/mint_multisig_key(seed,amount,challenger,opponent,game_multisig);

        let game_request_notification_record: GameReqNotification = GameReqNotification {
            owner: opponent, //opponent
            game_multisig: game_multisig,
            game_state: 1field,
            your_turn: true,
            total_pot: amount + amount,
            challenger_address: challenger,
            opponent_address: opponent,
        };

        let game_waiting_acceptance_notification_record: WaitingAcceptanceNotification = WaitingAcceptanceNotification {
            owner: challenger, //challenger
            game_multisig: game_multisig,
            game_state: 1field,
            your_turn: false,
            total_pot: amount + amount,
            challenger_address: challenger,
            opponent_address: opponent,
        };

        let game_record: Game = Game {
            owner: game_multisig,
            challenger_commit: challenger_commit,
            opponent_answer: answer,
            total_pot: amount + amount,
            challenger_address: challenger,
            opponent_address: opponent,
            game_multisig: game_multisig,
            game_state: 1field,
        };

        let (answer_record, audit_mint_answer_record):  (Answer, AuditMintAnswer) = multiparty_pvp_utils_v008.leo/mint_answer(
                challenger,
                opponent,
                game_multisig,
                amount,
                nonce,
                answer,
                message_1,
                message_2,
                message_3,
                message_4,
                message_5,
                sig
        );


        return (
            piece_claim,
            piece_stake,
            claim_signature,
            piece,
            audit_stake_in_record,
            answer_record,
            audit_mint_answer_record,
            key_record,
            audit_key_record,
            game_record,
            game_request_notification_record,
            game_waiting_acceptance_notification_record,
        );
    }

    // challenger calls this function with Multisig key and signature as input
    // that was submitted when proposing game and that exists on claim record
    transition challenger_renege_stake
    (
        waiting_accept_game_notification: WaitingAcceptanceNotification,
        piece_stake: puzzle_pieces_v008.leo/PieceStake.record,
        piece_claim: puzzle_pieces_v008.leo/PieceClaim.record,
        sig: signature,
    ) -> (
        puzzle_pieces_v008.leo/Piece.record,
        puzzle_pieces_v008.leo/AuditStakeOut.record,
        StakeRenegedNotification,
        StakeRenegedNotification,
        )
    {
        let (piece_record, audit_stake_out_record): (Piece, AuditStakeOut) = puzzle_pieces_v008.leo/stake_transfer_out(piece_stake, piece_claim, sig);

        let notify_challenger_stake_reneged: StakeRenegedNotification = StakeRenegedNotification {
            owner: waiting_accept_game_notification.challenger_address, //opponent
            game_multisig: waiting_accept_game_notification.game_multisig,
            game_state: 0field,
            your_turn: false,
            total_pot: waiting_accept_game_notification.total_pot,
            challenger_address: waiting_accept_game_notification.challenger_address,
            opponent_address: waiting_accept_game_notification.opponent_address,
            renege_address: waiting_accept_game_notification.challenger_address,
        };


        let notify_opponent_stake_reneged: StakeRenegedNotification = StakeRenegedNotification {
            owner: waiting_accept_game_notification.opponent_address, //opponent
            game_multisig: waiting_accept_game_notification.game_multisig,
            game_state: 0field,
            your_turn: false,
            total_pot: waiting_accept_game_notification.total_pot,
            challenger_address: waiting_accept_game_notification.challenger_address,
            opponent_address: waiting_accept_game_notification.opponent_address,
            renege_address: waiting_accept_game_notification.challenger_address,
        };

        return (piece_record, audit_stake_out_record, notify_challenger_stake_reneged, notify_opponent_stake_reneged);

    }

    // todo: implement renege for challenger


    transition submit_wager (
        wager_record: puzzle_pieces_v008.leo/Piece.record,
        key_record: multiparty_pvp_utils_v008.leo/Key.record,
        game_req_notification: GameReqNotification,
        message_1: field, //from output of useSignature
        message_2: field,
        message_3: field,
        message_4: field,
        message_5: field,
        sig: signature, //from output of useSignature
    ) -> (
        puzzle_pieces_v008.leo/PieceClaim.record,
        puzzle_pieces_v008.leo/PieceStake.record,
        puzzle_pieces_v008.leo/ClaimSignature.record,
        puzzle_pieces_v008.leo/Piece.record,
        puzzle_pieces_v008.leo/AuditStakeIn.record,
        ChallengerWagerNotification,
        OpponentWagerNotification,
    )
    {

        // Logic Checks
        // limit calls to only users
        assert_eq(self.caller, self.signer);

        // assert that the wager amount > 0 and wager inside credit == wager amt passed
        assert(wager_record.amount > 0u64);
        // assert that the wager record has >= total pot / 2u64
        assert(wager_record.amount >= game_req_notification.total_pot / 2u64);

        let (
            piece_claim,
            piece_stake,
            claim_signature,
            piece,
            audit_stake_in_record,
        ): (
            PieceClaim,
            PieceStake,
            ClaimSignature,
            Piece,
            AuditStakeIn
        ) = puzzle_pieces_v008.leo/stake_transfer_in(
            wager_record,
            game_req_notification.opponent_address, // sender
            game_req_notification.challenger_address, // challenger
            game_req_notification.opponent_address,
            game_req_notification.game_multisig,
            game_req_notification.total_pot / 2u64, // divide total pot by 2
            message_1,
            message_2,
            message_3,
            message_4,
            message_5,
            sig,
        );

        let challenger_submitted_wager_notification_record: ChallengerWagerNotification = ChallengerWagerNotification {
            owner: game_req_notification.challenger_address,
            game_multisig: game_req_notification.game_multisig,
            game_state: 1field,
            your_turn: false,
            total_pot: game_req_notification.total_pot,
            challenger_address: game_req_notification.challenger_address,
            opponent_address: game_req_notification.opponent_address,

        };

        let opponent_submitted_wager_notification_record: OpponentWagerNotification = OpponentWagerNotification {
            owner: game_req_notification.opponent_address,
            game_multisig: game_req_notification.game_multisig,
            game_state: 1field,
            your_turn: true,
            total_pot: game_req_notification.total_pot,
            challenger_address: game_req_notification.challenger_address,
            opponent_address: game_req_notification.opponent_address,
        };

        return (
            piece_claim,
            piece_stake,
            claim_signature,
            piece,
            audit_stake_in_record,
            challenger_submitted_wager_notification_record,
            opponent_submitted_wager_notification_record,
        );
    }
    // todo: implement renege for opponent

    // called by ms key after wager is confirmed on network
    transition accept_game
    (
        game_record: Game,
        opponent_answer: field,
        piece_stake_challenger: puzzle_pieces_v008.leo/PieceStake.record,
        piece_claim_challenger: puzzle_pieces_v008.leo/PieceClaim.record,
        piece_stake_opponent: puzzle_pieces_v008.leo/PieceStake.record,
        piece_claim_opponent: puzzle_pieces_v008.leo/PieceClaim.record,
        block_ht: u32,
    ) -> (
        puzzle_pieces_v008.leo/PieceJointStake.record,
        puzzle_pieces_v008.leo/JointPieceTimeClaim.record,
        puzzle_pieces_v008.leo/JointPieceState.record,
        puzzle_pieces_v008.leo/AuditJointStake.record,
        WaitingRevealNotification,
        RevealAnswerNotification,
        Game,
    )
    {

        let (
            piece_joint_stake,
            joint_piece_time_claim,
            joint_piece_state,
            audit_joint_stake
        ): (
            PieceJointStake,
            JointPieceTimeClaim,
            JointPieceState,
            AuditJointStake
        ) = puzzle_pieces_v008.leo/transfer_stakes_to_joint(
            piece_stake_challenger,
            piece_claim_challenger,
            piece_stake_opponent,
            piece_claim_opponent,
            block_ht,
        );

        // sent to opponent on accept_game
        // todo: how will user know they can claim if challenger never reveals answer?
        let waiting_reveal_answer_notifcation_record: WaitingRevealNotification = WaitingRevealNotification {
            owner: game_record.opponent_address,
            game_multisig: game_record.owner,
            game_state: 2field,
            your_turn: false,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
        };

        // sent to challenger on accept_game
        let reveal_answer_notification_record: RevealAnswerNotification = RevealAnswerNotification {
            owner: game_record.challenger_address,
            game_multisig: game_record.owner,
            game_state: 2field,
            your_turn: true,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            opponent_answer: opponent_answer,
        };

        let updated_game_record: Game = Game {
            owner: game_record.owner,
            challenger_commit: game_record.challenger_commit,
            opponent_answer: game_record.opponent_answer,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            game_multisig: game_record.game_multisig,
            game_state: 2field,
        };

        return (
            piece_joint_stake,
            joint_piece_time_claim,
            joint_piece_state,
            audit_joint_stake,
            waiting_reveal_answer_notifcation_record,
            reveal_answer_notification_record,
            updated_game_record,
        ) then finalize (block_ht);
    }


    finalize accept_game
    (
        block_ht: u32,
    )
    {
        // block every 5 seconds or so
        // would need to wait for time between `accept_game` req. from client to being proved
        // ~ 5s per block
        // leeway of 100 blocks = 100 * 5 = 500 / 60 = ~8.33 mins.
        // assert that block_ht passed in is within 100 blocks of current block ht.
        //
        // Check legit block height as input
        let current_block_ht: u32 = block.height;
        assert(block_ht >= current_block_ht - 100u32);
        assert(block_ht <= current_block_ht + 100u32);
    }

    // called by challenger to reveal answer record
    transition reveal_answer_game
    (
        reveal_answer_notification_record: RevealAnswerNotification,
        answer_record: multiparty_pvp_utils_v008.leo/Answer.record,
        joint_piece_state: puzzle_pieces_v008.leo/JointPieceState.record,
        claim_signature: puzzle_pieces_v008.leo/ClaimSignature.record,
        // sig: signature // using claimSignature record from beginning for this
    ) -> (
        multiparty_pvp_utils_v008.leo/RevealAnswer.record,
        multiparty_pvp_utils_v008.leo/AuditRevealAnswer.record,
        puzzle_pieces_v008.leo/JointPieceWinner.record,
        puzzle_pieces_v008.leo/AuditJointPieceWinner.record,
        GameFinishReqNotification,
        GameFinishReqNotification,
    )
    {

        assert_eq(joint_piece_state.state_updater_address, self.signer);
        // determine winner! If opponent correctly picked where the challenger hid alex, the opponent wins otherwise the challenger wins
        let winner_address: address = reveal_answer_notification_record.opponent_answer == answer_record.answer ? answer_record.opponent_address : answer_record.challenger_address;
        let sig: signature = claim_signature.sig;

        // retrieve revealedanswer record
        let (revealed_answer_record, audit_revealed_answer_record): (RevealAnswer, AuditRevealAnswer) = multiparty_pvp_utils_v008.leo/reveal_answer(answer_record, sig);

        let (joint_piece_winner, audit_joint_piece_winner): (JointPieceWinner, AuditJointPieceWinner) = puzzle_pieces_v008.leo/joint_stake_state_update(joint_piece_state, claim_signature, winner_address);

        let game_finish_req_notification_record_opponent: GameFinishReqNotification = GameFinishReqNotification {
            owner: answer_record.opponent_address,
            game_multisig: answer_record.game_address,
            game_state: 2field,
            your_turn: true,
            total_pot: joint_piece_state.amount,
            challenger_address: answer_record.challenger_address,
            opponent_address: answer_record.opponent_address,
        };

        let game_finish_req_notification_record_challenger: GameFinishReqNotification = GameFinishReqNotification{
            owner: answer_record.challenger_address,
            game_multisig: answer_record.game_address,
            game_state: 2field,
            your_turn: true,
            total_pot: joint_piece_state.amount,
            challenger_address: answer_record.challenger_address,
            opponent_address: answer_record.opponent_address,
        };

        return (revealed_answer_record, audit_revealed_answer_record, joint_piece_winner, audit_joint_piece_winner, game_finish_req_notification_record_opponent, game_finish_req_notification_record_challenger);
    }

    // called by ms key to finish the game and get the total pot!
    transition finish_game
    (
        game_record: Game,
        joint_piece_winner: puzzle_pieces_v008.leo/JointPieceWinner.record,
        piece_joint_stake: puzzle_pieces_v008.leo/PieceJointStake.record,
        joint_piece_time_claim: puzzle_pieces_v008.leo/JointPieceTimeClaim.record,
    ) -> (puzzle_pieces_v008.leo/Piece.record, puzzle_pieces_v008.leo/AuditTransferToWinner.record, Game, GameFinishedNotification, GameFinishedNotification)
    {

        let loser_address: address = joint_piece_winner.winner == game_record.challenger_address ? game_record.opponent_address : game_record.challenger_address;

        let (piece_record, audit_transfer_to_winner_record): (Piece, AuditTransferToWinner) = puzzle_pieces_v008.leo/joint_stake_transfer_to_winner(
            joint_piece_winner,
            piece_joint_stake,
            joint_piece_time_claim,
        );

        let updated_game_record: Game = Game {
            owner: game_record.owner,
            challenger_commit: game_record.challenger_commit,
            opponent_answer: game_record.opponent_answer,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field
        };

        let game_finished_notification_challenger_record: GameFinishedNotification = GameFinishedNotification {
            owner: game_record.challenger_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field,
            your_turn: false,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            winner: joint_piece_winner.winner,
            loser: loser_address,
        };

        let game_finished_notification_opponent_record: GameFinishedNotification = GameFinishedNotification {
            owner: game_record.opponent_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field,
            your_turn: false,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            winner: joint_piece_winner.winner,
            loser: loser_address,
        };

        return (piece_record, audit_transfer_to_winner_record, updated_game_record, game_finished_notification_challenger_record, game_finished_notification_opponent_record);
    }

    // called by ms key via opponent to finish the game and get the total pot!
    transition finish_game_by_timeout(
        game_record: Game,
        piece_joint_stake: puzzle_pieces_v008.leo/PieceJointStake.record,
        joint_piece_time_claim: puzzle_pieces_v008.leo/JointPieceTimeClaim.record,
        sig: signature, // use from ClaimSignature record on FE, can't consume in this fxn bc claim is owned by multisig
    ) -> (
        puzzle_pieces_v008.leo/Piece.record,
        puzzle_pieces_v008.leo/AuditTransferToWinner.record,
        Game,
        GameFinishedNotification,
        GameFinishedNotification)
    {

        // Update the game state
        let updated_game_record: Game = Game {
            owner: game_record.owner,
            challenger_commit: game_record.challenger_commit,
            opponent_answer: game_record.opponent_answer,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field
        };

        // Notification to challenger of game finished
        let game_finished_notification_challenger_record: GameFinishedNotification = GameFinishedNotification {
            owner: game_record.challenger_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field,
            your_turn: false,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            winner: game_record.opponent_address,
            loser: game_record.challenger_address,
        };

        // Notification to opponent of game finished
        let game_finished_notification_opponent_record: GameFinishedNotification = GameFinishedNotification {
            owner: game_record.opponent_address,
            game_multisig: game_record.game_multisig,
            game_state: 3field,
            your_turn: false,
            total_pot: game_record.total_pot,
            challenger_address: game_record.challenger_address,
            opponent_address: game_record.opponent_address,
            winner: game_record.opponent_address,
            loser: game_record.challenger_address,
        };

        // Payout to winner
        let (piece_record, audit_transfer_to_winner_record): (Piece, AuditTransferToWinner) = puzzle_pieces_v008.leo/joint_timeout_to_opponent(piece_joint_stake, joint_piece_time_claim, sig);

        return (
            piece_record,
            audit_transfer_to_winner_record,
            updated_game_record,
            game_finished_notification_challenger_record,
            game_finished_notification_opponent_record
        );
    }


    // // todo: do we want to limit this fn call only to users or will we allow contracts to call?
    // // todo: do we need to pass credits as input?
    // // player one proposes game
    // // outputs
    // // -> Answer record to player 1, to later reveal answer
    // // -> Claim record to player 1, to claim record if decides to pull back proposal before game is accepted
    // // -> Key record to player 2 to be able to reconstruct the game/multisig address
    // // -> OwnerRules record to the game/multisig address
    // // -> Game record to the game/multisig address
    // // -> PuzzRecord to the game/multisig address
    // // -> PuzzRecord to player 1 of any change from the wager credit

    // // todo: tweak messages here
    // // called by p1 key
    // transition propose_game
    // (
    //     private ms_seed: field,
    //     private game_address: address,
    //     private opponent: address,
    //     private wager: cflip_testing_123_token.leo/Piece.record,
    //     // private leo_credits: credits.leo/credits.record,
    //     // private credit_amount: u64,
    //     private wager_amount: u64,
    //     private player_one_answer: field,
    //     private sig: signature,
    //     private msg: field,
    //     private m_of_n: u8,
    //     private nonce: field,
    // ) -> (Answer, NotifyKeyRecord, Game, puzz_testing_acct_123.leo/OwnerRules.record, cflip_testing_123_token.leo/PieceClaim.record, cflip_testing_123_token.leo/Piece.record, cflip_testing_123_token.leo/Piece.record)
    // {
    //     // removing puzz_claim record for now

    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // random edge case, maybe unnecessary
    //     assert_neq(game_address, opponent);

    //     // assert that player 1s answer is either "in weeds" or "behind building"
    //     assert(player_one_answer == 0field || player_one_answer == 1field);
    //     // hash the answer and nonce
    //     let player_one_answer_comm: field = BHP256::commit_to_field(player_one_answer, nonce as scalar);

    //     // assert that the wager amount > 0 and wager inside credit == wager amt passed
    //     let wager_record: Piece = wager;
    //     assert(wager_amount > 0u64);
    //     // assert that the wager record has >= amount wagered
    //     assert(wager_record.amount >= wager_amount);

    //     // initialize key record with ms_address and seed for p2
    //     // so p2 can gen multisig locally
    //     // todo: we probably don't need address here?
    //     let notify_key_record: NotifyKeyRecord = NotifyKeyRecord {
    //         owner: opponent,
    //         keys: ms_seed,
    //         game_address: game_address,
    //         challenge_amount: wager_amount,
    //         opponent: self.caller,
    //     };

    //     // return answer record to player 1 in order to reveal later
    //     let answer_record: Answer = Answer {
    //         owner: self.caller,
    //         game_address: game_address,
    //         nonce: nonce,
    //         answer: player_one_answer,
    //     };

    //     // output game record
    //     let game_record: Game = Game {
    //         owner: game_address,
    //         challenger_commit: player_one_answer_comm,
    //         opponent_answer: 1field,
    //         total_pot: wager_amount,
    //         challenger_address: self.caller,
    //         opponent_address: opponent,
    //         game_state: 0field,
    //     };

    //     // output rules record with caller and opponent with game ms address
    //     // tbd on m of n here, or if even necessary
    //     // todo: send player 1 sig here and message to verify we can transfer on propose_game?
    //     let owner_rules_record: OwnerRules = puzz_testing_acct_123.leo/mint_owner_rules_record(game_address, self.caller, opponent, sig, sig);

    //     // stake puzz token in
    //     // todo: may be able to mint tokens to alice and then transfer to ms in this fn. logic and not require puzz tokens as input
    //     // let (puzz_claim_claim_record, puzz_receiver_record, puzz_sender_change_record): (PuzzClaim, Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_in(wager, self.caller, game_address, wager_amount);
    //     let (piece_claim_record, piece_receiver_record, piece_sender_change_record): (PieceClaim, Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_in(wager, self.caller, game_address, wager_amount, msg, sig);

    //     // todo: send credits to multisig
    //     // let creds_to_ms_record: (credits, credits) = credits.leo/transfer_private(leo_credits, game_address, credit_amount);

    //     // output claim record to game_addr if player 1 wants to renege or player 2 rejects
    //     // todo: will likely need to iterate on claim design here
    //     // let player_one_claim_record: Claim = puzz_testing_acct_123.leo/mint_claim_record(game_address, wager_amount);

    //     // transfer puzz tokens to game address
    //     // let (receiver_puzz_record, puzz_change): (Piece, Piece) = cflip_testing_123_token.leo/puzz_transfer_private(wager, game_address, wager_amount);


    //     // return (answer_record, player_two_key_record, game_record, owner_rules_record, token_owner_rules_record, puzz_claim_claim_record, puzz_receiver_record, puzz_sender_change_record) then finalize(game_address);
    //     return (answer_record, notify_key_record, game_record, owner_rules_record, piece_claim_record, piece_receiver_record, piece_sender_change_record) then finalize(game_address);
    // }


    // finalize propose_game (game_address: address) {
    //     Mapping::set(games, game_address, block.height);
    // }

    // // called by ms key
    // transition player_one_renege_proposal
    // (
    //     private game_record: Game,
    //     // private ms_rules: puzz_testing_acct_123.leo/OwnerRules.record,
    //     private token_owner_rules: cflip_testing_123_token.leo/TokenOwnerRules.record,
    //     private player_one_claim_record: cflip_testing_123_token.leo/PieceClaim.record,
    //     private piece_record: cflip_testing_123_token.leo/Piece.record,
    //     private amount: u64,
    //     // private sig: signature, // player 1 sig
    //     // private msg: field, // msg generated on propose_game with nonce
    // ) -> (cflip_testing_123_token.leo/Piece.record, cflip_testing_123_token.leo/Piece.record)
    // {
    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // transfer out and check player 1 sig and message that is signed
    //     // let (receiver_puzz_record, puzz_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(puzz_record, token_owner_rules, player_one_claim_record, sig, msg, amount);
    //     let (receiver_piece_record, piece_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(piece_record, player_one_claim_record, self.caller, amount);

    //     return (receiver_piece_record, piece_record);

    //     // todo: what clean-up do we need to do here?
    // }

    // // finalize player_one_renege_proposal (game_address: address) {
    // //     let previous_block_height: u32 = Mapping::get(games, game_address);
    // //     assert(block.height > previous_block_height);
    // //     Mapping::set(games, game_address, block.height);
    // // }

    // // todo: how do we check bob is wagering the correct amount before wager submission
    // // called by player 2 key
    // transition submit_wager (
    //     private game_address: address,
    //     private opponent: address,
    //     private wager: cflip_testing_123_token.leo/Piece.record,
    //     private wager_amount: u64,
    //     // private nonce: field,
    //     private msg: field,
    //     private sig: signature,
    // ) -> (cflip_testing_123_token.leo/PieceClaim.record, cflip_testing_123_token.leo/Piece.record, cflip_testing_123_token.leo/Piece.record) {

    //     // todo: removing claim record for now
    //     // todo: may be able to mint tokens to alice and then transfer to ms in this fn. logic and not require puzz tokens as input
    //     let (piece_claim_record, piece_receiver_record, piece_sender_change_record): (PieceClaim, Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_in(wager, self.caller, game_address, wager_amount, msg, sig);

    //     // let (receiver_puzz_record, puzz_change): (Piece, Piece) = cflip_testing_123_token.leo/puzz_transfer_private(wager, game_address, wager_amount);

    //     // let player_two_claim_record: Claim = puzz_testing_acct_123.leo/mint_claim_record(game_address, wager_amount);

    //     // return (token_owner_rules_record, puzz_claim_record, puzz_receiver_record, puzz_sender_change_record);
    //     return (piece_claim_record, piece_receiver_record, piece_sender_change_record);

    // }

    // // called by ms key
    // transition player_two_renege_proposal (
    //     private game_record: Game,
    //     // private ms_rules: puzz_testing_acct_123.leo/OwnerRules.record,
    //     // private token_owner_rules: cflip_testing_123_token.leo/TokenOwnerRules.record,
    //     private player_two_claim_record: cflip_testing_123_token.leo/PieceClaim.record,
    //     private piece_record: cflip_testing_123_token.leo/Piece.record,
    //     private amount: u64,
    //     // private sig: signature, // player 1 sig
    //     // private msg: field, // msg generated on propose_game with nonce
    // ) -> (cflip_testing_123_token.leo/Piece.record, cflip_testing_123_token.leo/Piece.record)
    // {
    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // transfer out and check player 1 sig and message that is signed
    //     // let (receiver_puzz_record, puzz_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(puzz_record, token_owner_rules, player_two_claim_record, sig, msg, amount);
    //     let (receiver_piece_record, piece_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(piece_record, player_two_claim_record, self.caller, amount);

    //     return (receiver_piece_record, piece_change);
    //     // todo: what clean-up do we need to do here?
    //     // todo: update game state to finished/tbd if we need sep states between finished and cancelled/rejected
    // }

    // // called by ms key
    // transition accept_game (
    //     private game_record: Game,
    //     // private player_one_claim_record: puzz_testing_acct_123.leo/Claim.record,
    //     // private player_two_claim_record: puzz_testing_acct_123.leo/Claim.record,
    //     // todo: do we need puzz record here/what for? since puzz record is already transferred to ms
    //     // private puzz_record: cflip_testing_123_token.leo/Piece.record,
    //     // private owner_rules_record: puzz_testing_acct_123.leo/OwnerRules.record,
    //     private opponent_answer: field,
    //     // private player_two_signature: signature,
    //     // todo: adjust msg type here
    //     // private leo_message: field,
    // ) -> (Game, NotifyAcceptGame)
    // {
    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // assert that each player has wagered the same amount
    //     // assert_eq(player_one_claim_record.amount, player_two_claim_record.amount);

    //     // assert that the game_address matches on player claim records and game record
    //     // assert_eq(player_one_claim_record.owner, player_two_claim_record.owner);
    //     // assert_eq(game_record.owner, player_one_claim_record.owner);

    //     // assert that the game is in the propose_state status
    //     assert_eq(game_record.game_state, 0field);

    //     // assert that player 1s answer is either "in weeds" or "behind building"
    //     assert(opponent_answer == 0field || opponent_answer == 1field);

    //     // add player 2's answer to the game record
    //     // todo: answers will need to be hashed?
    //     let game_record_new: Game = Game {
    //         owner: game_record.owner,
    //         challenger_commit: game_record.challenger_commit,
    //         opponent_answer: opponent_answer,
    //         total_pot: game_record.total_pot,
    //         challenger_address: game_record.challenger_address,
    //         opponent_address: game_record.opponent_address,
    //         game_state: 1field, // update to game accepted
    //     };

    //     // notify player 1 that the game has been accepted
    //     let notify_accept_game_record: NotifyAcceptGame = NotifyAcceptGame {
    //         owner: game_record.challenger_address,
    //         total_pot: game_record.total_pot,
    //         game_address: game_record.owner,
    //         opponent: game_record.challenger_address,
    //     };

    //     // note: will need to tweak owner rules structure likely to include sig to lock next turn
    //     // let new_owner_rules: OwnerRules =
    //     // puzz_testing_acct_123.leo/mint_owner_rules_record(game_record.owner, self.caller, player_one_claim_record.signer_address, player_two_signature, player_two_signature);

    //     // todo: tweak for notify records
    //     // output owner rules record to ms so bob can claim later on
    //     // return (game_record_new, new_owner_rules) then finalize(game_record.owner);
    //     return (game_record_new, notify_accept_game_record) then finalize(game_record.owner);
    // }

    // finalize accept_game (game_address: address) {
    //     let previous_block_height: u32 = Mapping::get(games, game_address);
    //     assert(block.height > previous_block_height);
    //     Mapping::set(games, game_address, block.height);
    // }

    // // called by p1 key
    // transition reveal_answer (
    //     private answer_record: Answer,
    //     private game_address: address,
    //     private opponent_address: address,
    // ) -> (RevealedAnswer, GameReqNotification)
    // {

    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     let revealed_answer: RevealedAnswer = RevealedAnswer {
    //         owner: game_address,
    //         answer: answer_record.answer,
    //         nonce: answer_record.nonce,
    //     };

    //     // send notify reveal record answer to player 2
    //     let notify_reveal_answer_p2: GameReqNotification = GameReqNotification {
    //         owner: opponent_address,
    //         answer: answer_record.answer,
    //         game_address: game_address,
    //         opponent: answer_record.owner,
    //     };

    //     return (revealed_answer, notify_reveal_answer_p2);
    // }


    // // called by ms key
    // transition finish_game (
    //     private game_record: Game,
    //     private revealed_answer_record: RevealedAnswer,
    //     private piece_record: cflip_testing_123_token.leo/Piece.record,
    //     private player_claim_record: cflip_testing_123_token.leo/PieceClaim.record,
    //     // private puzz_stake_two: cflip_testing_123_token.leo/PuzzStake.record,
    //     // private token_owner_rules: cflip_testing_123_token.leo/TokenOwnerRules.record,
    //     // private sig: signature,
    //     // private msg: field,
    // ) -> (NotifyGameOver, NotifyGameOver)
    // {
    //     // todo: how do we transfer out from ms/game addr to winner
    //     // todo: do we just mint new tokens to winner?
    //     // todo: add logic here to transfer to correct winner
    //     // todo: how are we going to get player 1 and player 2 addresses here?
    //     // todo: adjust revealing logic now that we are hashing p1's answer

    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // assert that the game has been accepted
    //     assert_eq(game_record.game_state, 1field);

    //     // player 1 loses, player 2 wins
    //     if (revealed_answer_record.answer == game_record.opponent_answer) {
    //         // transfer all funds to winner
    //         let (receiver_piece_record, piece_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(piece_record, player_claim_record, game_record.opponent_address, game_record.total_pot);
    //         // cflip_testing_123_token.leo/stake_transfer_private_out(puzz_record, token_owner_rules, player_claim_record, sig, msg, player_claim_record.amount * 2u64);

    //         // notify p1 and p2 the game is over
    //         let notify_game_over_p1_record: NotifyGameOver = NotifyGameOver {
    //             owner: game_record.challenger_address,
    //             winner: game_record.opponent_address,
    //             total_pot: game_record.total_pot,
    //             game_address: game_record.owner,
    //             opponent: game_record.opponent_address,
    //         };
    //         let notify_game_over_p2_record: NotifyGameOver = NotifyGameOver {
    //             owner: game_record.opponent_address,
    //             winner: game_record.opponent_address,
    //             total_pot: game_record.total_pot,
    //             game_address: game_record.owner,
    //             opponent: game_record.challenger_address,
    //         };
    //         // todo: return puzz records, some weird puzz undefined bug popping up
    //         return (notify_game_over_p1_record, notify_game_over_p2_record) then finalize(game_record.owner);
    //     }
    //     // player 1 wins, player 2 loses
    //     else {
    //         // transfer all funds to winner
    //         let (receiver_piece_record, piece_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(piece_record, player_claim_record, game_record.challenger_address, game_record.total_pot);
    //         // notify p1 and p2 the game is over
    //         let notify_game_over_p1_record: NotifyGameOver = NotifyGameOver {
    //             owner: game_record.challenger_address,
    //             winner: game_record.challenger_address,
    //             total_pot: game_record.total_pot,
    //             game_address: game_record.owner,
    //             opponent: game_record.opponent_address,
    //         };
    //         let notify_game_over_p2_record: NotifyGameOver = NotifyGameOver {
    //             owner: game_record.opponent_address,
    //             winner: game_record.challenger_address,
    //             total_pot: game_record.total_pot,
    //             game_address: game_record.owner,
    //             opponent: game_record.challenger_address,
    //         };
    //         // todo: return puzz records, some weird puzz undefined bug popping up
    //         return (notify_game_over_p1_record, notify_game_over_p2_record) then finalize(game_record.owner);
    //     }
    // }

    // finalize finish_game (game_address: address) {
    //     let previous_block_height: u32 = Mapping::get(games, game_address);
    //     assert(block.height > previous_block_height);
    //     Mapping::set(games, game_address, block.height);
    // }

    // // called by ms key
    // transition claim_total_pot (
    //     private game_record: Game,
    //     private revealed_answer_record: RevealedAnswer,
    //     private piece_record: cflip_testing_123_token.leo/Piece.record,
    //     private player_claim_record: cflip_testing_123_token.leo/PieceClaim.record,
    //     // private puzz_stake_two: cflip_testing_123_token.leo/PuzzStake.record,
    //     // private token_owner_rules: cflip_testing_123_token.leo/TokenOwnerRules.record,
    //     // private sig: signature,
    //     // private msg: field,
    // ) -> (cflip_testing_123_token.leo/Piece.record, cflip_testing_123_token.leo/Piece.record, NotifyGameOver, NotifyGameOver)
    // {
    //     // todo: if alice never reveals answer than bob gets to claim total pot
    //     // limit calls to only users
    //     assert_eq(self.caller, self.signer);

    //     // need to assert that player 2 valid signature and valid message signed here, will validate inside stake transfer private logic
    //     // let (receiver_puzz_record, puzz_change): (Piece, Piece) =
    //         // cflip_testing_123_token.leo/stake_transfer_private_out(puzz_record, token_owner_rules, player_claim_record, sig, msg, player_claim_record.amount * 2u64);
    //     let (receiver_piece_record, piece_change): (Piece, Piece) = cflip_testing_123_token.leo/stake_transfer_private_out(piece_record, player_claim_record, self.caller, game_record.total_pot);

    //     let notify_game_over_p1_record: NotifyGameOver = NotifyGameOver {
    //             owner: game_record.challenger_address,
    //             winner: game_record.opponent_address,
    //             total_pot: game_record.total_pot,
    //             game_address: game_record.owner,
    //             opponent: game_record.opponent_address,
    //         };

    //     let notify_game_over_p2_record: NotifyGameOver = NotifyGameOver {
    //         owner: game_record.opponent_address,
    //         winner: game_record.opponent_address,
    //         total_pot: game_record.total_pot,
    //         game_address: game_record.owner,
    //         opponent: game_record.challenger_address,
    //     };

    //     return (receiver_piece_record, piece_change, notify_game_over_p1_record, notify_game_over_p2_record) then finalize(game_record.owner);
    // }

    // finalize claim_total_pot (game_address: address) -> () {
    //     // todo: change logic here to assert that a certain amount of time has passed to allow p2 to claim total pot
    //     let previous_block_height: u32 = Mapping::get(games, game_address);
    //     assert(block.height > previous_block_height + 1000u32);
    //     Mapping::set(games, game_address, block.height);
    // }
}